{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gabriele Ara","text":"A nice picture of me <p>   Check out my Resume </p>"},{"location":"#quick-bits","title":"Quick bits","text":"<p>I was born in 1994 in Livorno, Italy. Ever since I was little, I was fascinated by everything that revolved around computers and such. I made it my life mission to learn everything I could about computers, how to use them and how they worked, hoping that I'd be good enough to work with them someday.</p>"},{"location":"#current-occupation","title":"Current occupation","text":"<p>Currently, I'm a Postdoctoral Researcher at Scuola Superiore Sant'Anna in Pisa, Italy. I proudly work in the Real-Time Systems Laboratory (ReTiS Lab) under the supervision of Prof. Tommaso Cucinotta.</p> <p>My research activity focuses in Emerging Digital Technologies and Embedded Systems. In particular, I conduct research on the energy consumption of real-time tasks on embedded platforms, like ARM-based devices running Linux.</p>"},{"location":"#want-more","title":"Want more?","text":"<p>Stick around if you want to learn more, maybe checking out my about page.</p> <p>Or maybe check out my full list of research publications.</p>"},{"location":"about/","title":"About me","text":""},{"location":"about/#about-me","title":"About me","text":"<p>This page contains information pertaining my past and current work and educational experience.</p>"},{"location":"about/#education","title":"Education","text":""},{"location":"about/#high-school","title":"High school","text":"<p>In my pursuit of knowledge about computing systems, I first chose to study to become an IT Professional in high school at Istituto Tecnico Industriale Statale G. Galilei, Livorno (Italy), graduating with a final mark of 100/100 in June, 2013.</p> <p>In high school I learned the basics of programming, a few programming languages, commonly used programming patterns, web technologies, mobile app development, and networking. My schooling experience was also enriched by the participation to a few student competitions, which pushed me to obtain extra knowledge and competences, in addition to the ones acquired during classes.</p>"},{"location":"about/#bachelor-years","title":"Bachelor years","text":"<p>After that, I enrolled in University of Pisa (Italy) to obtain a Bachelor Degree in Computer Engineering. During my bachelor years I expanded my knowledge of computer science, along with other engineering areas. In particular I learned about computer architectures, system programming, industrial automation and control systems.</p> <p>For my bachelor's thesis, I worked on a system for the generation of dynamic and interactive crisis maps. This work, along with my weighted average grades of over 29/30, granted me a final graduation mark of 110 cum laude/110, in September, 2016.</p>"},{"location":"about/#master-years","title":"Master years","text":"<p>For my master's program I joined Scuola Superiore Sant'Anna in Pisa, Italy to obtain a Master of Science in Computer Engineering and Embedded Computing Systems. Throughout my master's program I enhanced my knowledge of control systems and system programming. During this time I was exposed to real-time systems, mechatronics, computer architectures, and component frameworks.</p> <p>For my master thesis, I developed a framework for evaluating the performance of various virtual network switching solutions for Network Function Virtualization (NFV)-like scenarios. You can read my master thesis (along with the papers I published on said work) on my publications page. I then graduated with a final mark of 110 cum laude/110 in October, 2019.</p>"},{"location":"about/#doctorate-years","title":"Doctorate years","text":"<p>From October 2019 to December 2022, I've been a Ph.D. Student at Scuola Superiore Sant'Anna in Pisa, Italy, in the Real-Time Systems Laboratory (ReTiS Lab) under the supervision of Prof. Tommaso Cucinotta. During this time, I also spent over 6 months abroad in Switzerland, at the Integrated Systems Laboratory of ETH Z\u00fcrich, under the supervision of Prof. Luca Benini.</p> <p>My research activity focused in Emerging Digital Technologies and Embedded Systems. In particular, I conduct research on the energy consumption of real-time tasks on embedded platforms, like ARM-based devices running Linux.</p> <p>Check out my publications page for some of the works I contributed to. My Ph.D. Thesis has already been approved, but it is currently under embargo for a couple of years, due to some topics missing a publication (yet!).</p>"},{"location":"about/#current-occupation","title":"Current Occupation","text":"<p>From January 2023 I am a Postdoctoral Researcher at the ReTiS Lab, following up on the topics that I worked on during my Ph.D. and collaborating to an European Project, AMPERE.</p>"},{"location":"about/#prior-work-experience","title":"Prior Work Experience","text":""},{"location":"about/#authorship-of-books-and-book-chapters","title":"Authorship of Books and Book Chapters","text":"<p>On \"odd\" years (2013, 2015, 2017, 2019, 2021) I typically work as an independent contract author for Zanichelli editore (Italy). In the past I collaborated this way to a number of projects, authoring some chapters for high-school textbooks and manuals regarding the essentials of mobile application development for Android OS. Refer to my publications list for the full list of my contributions.</p>"},{"location":"about/#high-school-teaching-and-tutoring","title":"High-School Teaching and Tutoring","text":"<p>Between October 2018 and June 2019, during my senior year as a master student, I worked as a (part-time) high-school teacher for the Istituto di Istruzione Superiore \"Vespucci-Colombo\", Livorno (Italy), teaching IT and IT Laboratory for the school year 2018-2019 to both 10<sup>th</sup> and 11<sup>th</sup> grade students.</p> <p>Throughout my university years I managed to help some high school students in STEM fields as their tutor, helping them with assignments in classes such as IT, Math, Electronics, and Physics.</p>"},{"location":"about/#computer-assistance-for-streaming-and-media-recording","title":"Computer Assistance for Streaming and Media Recording","text":"<p>While studying for my Master's Degree, I also had a part-time job as a computer assistant for University of Pisa (Italy). My role was to assist technical-administrative personnel and teaching staff to provide live streaming of classes and international conferences held at University of Pisa.</p>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/","title":"Linux kernel development in a containerized environment using VS Code","text":"<p>This short guide will let you create your own containerized environment to develop and tinker with the Linux kernel without having to install any particular software/tool on your machine that you may not already have.</p>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/#requirements","title":"Requirements","text":"<p>This guide will require little to no tools installed on your machine. However, some tools will have to be installed to work properly.</p> <p>First of all, you need an OS. Any Linux desktop distribution will do. For other OSes (Windows or macOS) instructions may pop out in this section soon.</p> <p>In addition, you need the following tools installed on your machine inside the OS of choice:</p> <ol> <li>Visual Studio Code</li> <li>Docker</li> </ol> <p>Since you are on this page, you most likely are already interested in developing stuff inside VS Code in containerized environments, so you should have both already installed. If not, do it.</p> <p>That's it, I told you that there wouldn't be many requirements for this guide to work! </p>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/#setting-up-your-workspace","title":"Setting up your workspace","text":"<p>First of all you need to create an empty directory in which you plan to work and to open it as a workspace inside VS Code. For my examples, the directory will be simply called <code>kernel_dev</code>.</p> <p>Note</p> <p>You can also do this by cloning the Linux kernel from your relevant source and opening it inside VS Code. In this guide, I will use a separate directory for the kernel source inside the base directory of the project. This will be useful if one wants to develop its own modules inside the workspace without tainting the kernel directory structure.</p> <p>Once you have it open, create the following directory structure:</p> <pre><code>kernel_dev\n\u2514\u2500\u2500 .devcontainer\n    \u251c\u2500\u2500 devcontainer.json\n    \u2514\u2500\u2500 Dockerfile\n</code></pre> <p>The two created files will instruct VS Code how to treat your directory as a Development Container workspace. I will not go into much details of how the process of developing workspaces inside a container with VS Code works. For that, see the official documentation.</p> <p>For the sake of this discussion it will suffice to say that using these files VS Code is able to detect whether a workspace should be opened inside a container, bring up the container, mount the workspace folder as a shared folder inside the automatically instantiated container. Once the automated process is done, it will look and feel as if you are working on a folder in your host, but in reality you are developing inside a container. Magic! </p> <p>The content of the two files should be the following:</p> Dockerfiledevcontainer.json <pre><code># Base image for the container environment\nFROM gabrieleara/dev_environment:kernel\n\n# You can place other dependencies here if you want.\n# The container is a standard debian image, so you can\n# use apt-get freely to install more dependencies.\n\n# Also, you can copy scripts to run at boot of this\n# container image by using COPY commands with the\n# directory /opt/startup-scripts as destination\n</code></pre> <pre><code>// Configuration of the development container\n{\n    \"name\": \"Kernel\",\n    \"build\": {\n        // Use the Dockerfile in the same directory as container image\n        \"dockerfile\": \"Dockerfile\"\n    },\n    // Arguments provided to the docker run command by VS Code.\n    // Each and every one of them is necessary for the project\n    // to work properly. You may not need some options if you only\n    // develop and build the kernel in this container, but if you\n    // need to run and debug it inside QEMU they are *ALL* necessary.\n    \"runArgs\": [\n        \"-e\",\n        \"DISPLAY=${env:DISPLAY}\",\n        \"-v\",\n        \"/tmp/.X11-unix:/tmp/.X11-unix\",\n        \"-e\",\n        \"QT_GRAPHICSSYSTEM=native\",\n        \"--device=/dev/dri:/dev/dri\",\n        \"--cap-add=SYS_PTRACE\",\n        \"--security-opt\",\n        \"seccomp=unconfined\",\n        \"--privileged\",\n        \"-v\",\n        \"/var/run/libvirt:/var/run/libvirt\"\n    ],\n    // List of VS Code extension IDs that will be automatically\n    // installed inside the container instance\n    \"extensions\": [\n        \"ms-vscode.cpptools\",\n        \"ms-vscode.cmake-tools\",\n        \"eamodio.gitlens\"\n    ],\n    // Important: use this to login as vscode user, rather than root\n    \"remoteUser\": \"vscode\",\n    // This option is necessary. The image that i built needs to run\n    // some commands at container startup and for that I had to set\n    // the ENTRYPOINT of the Docker container accordingly.\n    \"overrideCommand\": false,\n}\n</code></pre> <p>Note</p> <p>While I write this document, the options in the <code>devcontainer.json</code> file listed here are all accurate. However, I cannot guarantee that it will always be the case.</p> <p>For a more recent version of this file, refer to this link to my GitHub repository where I keep all these virtualized environments configurations.</p>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/#opening-the-workspace-in-the-container","title":"Opening the workspace in the container","text":"<p>Once the content of the two files is filled accordingly, open VS Code command palette Ctrl+Shift+P and use the following command to reopen your workspace inside the specified container:</p> <pre><code>Remote-Containers: Rebuild and Reopen in Container\n</code></pre> <p>Once started, this command will build the relevant container image and bring up the workspace in the new environment. This may take a while. Once this process is done you should get your workspace now open inside the container. If you open a terminal from inside VS Code you should get a prompt from inside the container and everything.</p> <p>At this point if you are not working from inside the kernel directory already you should clone the Linux kernel code form your relevant source and place it somewhere inside the workspace. For me, that directory will be called (unsurprisingly) <code>linux</code>. However, keep it in mind for the next steps.</p> <p>For the sake of clarity, this is the content of my workspace at the end of this step:</p> <pre><code>kernel_dev\n\u251c\u2500\u2500 .devcontainer\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 devcontainer.json\n\u2514\u2500\u2500 linux\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/#configuring-and-building-the-linux-kernel","title":"Configuring and building the Linux kernel","text":"<p>Now it's time to configure and build the Linux kernel. This can be done by using the terminal inside VSCode, but for further convenience here is a configuration file that can be used to run build tasks from VS Code command palette.</p> <p>This file must be placed inside the <code>.vscode</code> directory in the root of the workspace and each mention of the path <code>${workspaceFolder}/linux</code> must be adapted to reflect the actual location of your Linux source tree inside your workspace.</p> tasks.json <pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            // Generates a new configuration file for the\n            // Linux kernel using the default one.\n            \"label\": \"defconfig\",\n            \"type\": \"shell\",\n            \"command\": \"make -C ${workspaceFolder}/linux defconfig\",\n            \"problemMatcher\": [],\n        },\n        {\n            // Re-configures the Linux kernel by checking the modifications in\n            // the .config file.\n            \"label\": \"oldconfig\",\n            \"type\": \"shell\",\n            \"command\": \"make -C ${workspaceFolder}/linux oldconfig\",\n            \"problemMatcher\": [],\n        },\n        {\n            // Builds the entire Linux kernel using several parallel jobs.\n            \"label\": \"build\",\n            \"type\": \"shell\",\n            \"command\": \"make -C ${workspaceFolder}/linux -j $(nproc)\",\n            \"problemMatcher\": [],\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n    ]\n}\n</code></pre> <p>Now you can use VS Code Command Palette to run these tasks. First, use the <code>defconfig</code> task to generate a default config (if you don't already have a <code>.config</code> task specific for your purposes).</p> <p>After that you have to append the following lines at the end of the <code>.config</code> file generated inside Linux source tree root. In the listing, the options marked as \"optional\" can be omitted if not necessary. Feel free to make any other modification that you like to the <code>.config</code> configuration as long as you maintain the mandatory options.</p> <pre><code># Mandatory options:\nCONFIG_DEBUG_INFO=y             # Enable debug information\n\n# Optional options:\nCONFIG_READABLE_ASM=y           # Generates more readable ASM instructions\nCONFIG_DEBUG_SECTION_MISMATCH=y # Enables mismatch analysis\n</code></pre> <p>You can then use the <code>oldconfig</code> task to check that your kernel configuration is correct or to check whether you need to supply other information. During the execution of this task, you may be prompted yes/no questions. If you don't really know what you're doing you can simply type Enter for each of them and accept the default values.</p> <p>Note</p> <p>Typically, one would disable <code>CONFIG_RANDOMIZE_MEMORY</code> to debug the Linux kernel, otherwise debug symbols will be scrambled each time it boots, making it impossible to debug.</p> <p>For this guide, I prefer to fiddle as little as possible with the kernel configuration and use instead a boot argument to disable address randomization inside the kernel, so you can leave it enabled.</p> <p>Now that your kernel is configured, it is time to build it. You can use the <code>build</code> task above to do it in a parallel fashion. It is also configured as the default build task for the workspace, so you can use Ctrl+Shift+B to start the whole build process.</p> <p>Once the build task is done you have your own build of the Linux kernel that you can run and debug.</p>"},{"location":"blog/2021/11/04/linux-kernel-development-in-a-containerized-environment-using-vs-code/#running-and-debugging-the-linux-kernel","title":"Running and debugging the Linux kernel","text":"<p>At this point all is left is to run and debug the build Linux kernel. Beware though that you need a proper filesystem image to run Linux, otherwise the Linux kernel will not be able to find appropriate tools to start processes and such.</p> <p>You can find a minimal image built using BusyBox here. Download it and place it inside your workspace. I will put mine in the workspace root folder.</p> <p>Now all you need is a launch configuration file for VS Code. You can use the following one and place it inside the <code>.vscode</code> directory as well. In the file, the location of the Linux kernel directory <code>${workspaceFolder}/linux</code> and the file system to use <code>${workspaceFolder}/tinyfs.gz</code> must be changed according to where you placed them in your workspace.</p> launch.json <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            // Use this launch configuration first to run QEMU using the\n            // kernel built at the previous step. It will also automatically\n            // invoke the build process before running, so you can just\n            // start this launch configuration whenever you are done typing\n            // code and it will automatically do everything for you.\n            \"name\": \"(gdb) Start Kernel in QEMU\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"/usr/bin/qemu-system-x86_64\",\n            // Do not fiddle with these arguments if you do not know\n            // what you're doing!\n            \"args\": [\n                \"-s\",\n                \"-S\",\n                \"-kernel\",\n                \"${workspaceFolder}/linux/arch/x86_64/boot/bzImage\",\n                \"-append\",\n                \"nokaslr\",\n                \"-initrd\",\n                \"${workspaceFolder}/tinyfs.gz\",\n            ],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${fileDirname}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"preLaunchTask\": \"${defaultBuildTask}\",\n        },\n        {\n            // Once the previous launch succeeded and you see on screen the\n            // QEMU window waiting for the debugger, run this configuration,\n            // which will attach the visual debugger of VS Code to your\n            // kernel instance running in the emulator.\n            \"name\": \"(gdb) Attach to QEMU Kernel\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/linux/vmlinux\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${fileDirname}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"symbolSearchPath\": \"${fileDirname}\",\n            \"miDebuggerServerAddress\": \"localhost:1234\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                },\n            ],\n        },\n    ]\n}\n</code></pre> <p>Follow the instructions in the comments above to launch the kernel instance inside the emulator and attach the VS Code debugger to it. After that the kernel will start running and you can stop it using breakpoints wherever in your kernel code.</p> <p>Both launch configurations shall be running at the same time for the process to work, and you shall always start the first one before the other. Unfortunately, as far as I know there is no automated way to run them both at the same time, but it's not particularly tedious to do after all the work I did for you. </p> <p>Just to recap, this is the final tree of the workspace directory once everything is set in place. You may have some files placed differently, but as long as you substitute all the paths accordingly in the <code>tasks.json</code> and <code>launch.json</code> configuration files you are good. </p> <p>Happy Linux Kernel Hacking with VS Code! </p> <pre><code>kernel_dev\n.devcontainer\n\u2502   \u251c\u2500\u2500 devcontainer.json\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 linux\n\u251c\u2500\u2500 tinyfs.gz\n\u2514\u2500\u2500 .vscode\n    \u251c\u2500\u2500 launch.json\n    \u2514\u2500\u2500 tasks.json\n</code></pre>"},{"location":"publications/","title":"List of Publications","text":"<p>Following is my list of publications, divided into publication types.</p> <p>Note</p> <p>For now, the list does not contain details of each publication, just an identifier that will lead you to the actual publication page.</p> <p>I apologize for the inconvenience .</p>"},{"location":"blog/archive/2021/","title":"2021","text":""}]}